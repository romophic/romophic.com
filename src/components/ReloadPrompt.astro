<!-- "Update Available" Toast for subsequent updates -->
<div
  id="pwa-toast"
  role="alert"
  aria-labelledby="toast-message"
  class="bg-background text-foreground fixed right-4 bottom-4 z-50 w-full max-w-sm translate-y-[150%] rounded-lg border p-4 shadow-lg transition-transform duration-300 data-[open=true]:translate-y-0 dark:border-zinc-800"
>
  <div class="flex items-start gap-3">
    <div class="flex-1">
      <h3 id="toast-message" class="text-sm font-medium">Update available</h3>
      <p class="text-muted-foreground mt-1 text-xs">
        New content is available, click on reload button to update.
      </p>
    </div>
    <div class="flex flex-col gap-2">
      <button
        id="pwa-refresh"
        type="button"
        class="bg-primary text-primary-foreground hover:bg-primary/90 focus-visible:ring-ring inline-flex items-center justify-center rounded-md px-3 py-1.5 text-xs font-medium shadow focus-visible:ring-1 focus-visible:outline-none"
      >
        Reload
      </button>
      <button
        id="pwa-close"
        type="button"
        class="text-muted-foreground hover:bg-muted hover:text-foreground focus-visible:ring-ring inline-flex items-center justify-center rounded-md border bg-transparent px-3 py-1.5 text-xs font-medium shadow-sm focus-visible:ring-1 focus-visible:outline-none"
      >
        Close
      </button>
    </div>
  </div>
</div>

<!-- "Downloading for Offline" Progress for initial install in standalone mode -->
<div
  id="pwa-progress-wrapper"
  role="status"
  aria-live="polite"
  data-open="false"
  class="bg-background text-foreground fixed left-4 bottom-4 z-50 w-full max-w-sm translate-y-[150%] rounded-lg border p-4 shadow-lg transition-transform duration-300 data-[open=true]:translate-y-0 dark:border-zinc-800"
>
  <div class="flex items-center justify-between">
    <p class="text-sm font-medium">Downloading for offline use...</p>
    <p id="pwa-progress-text" class="text-muted-foreground text-xs"></p>
  </div>
  <div class="bg-muted mt-2 h-2 w-full overflow-hidden rounded-full">
    <div
      id="pwa-progress-bar"
      class="bg-primary h-full w-0 transition-width duration-300"
    ></div>
  </div>
</div>

<script>
  const CACHE_COMPLETED_KEY = 'content-cached-v1.1' // Matches SW cache version

  // --- UI Elements ---
  const progressWrapper = document.getElementById('pwa-progress-wrapper')
  const progressBar = document.getElementById('pwa-progress-bar')
  const progressText = document.getElementById('pwa-progress-text')

  // --- Logic for "Update Available" Toast ---
  async function runPwaInstallLogic() {
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches
    const isCached = localStorage.getItem(CACHE_COMPLETED_KEY) === 'true'

    // Only run this logic if in PWA mode and content isn't cached yet
    if (!isStandalone || isCached) {
      return
    }

    try {
      const reg = await navigator.serviceWorker.ready
      if (!reg.active) {
        console.log('No active service worker found. Caching will be handled on next load.')
        return
      }

      console.log('PWA is in standalone mode and content is not cached. Starting download.')

      // Show the progress UI
      progressWrapper?.setAttribute('data-open', 'true')

      // Listen for progress messages from the Service Worker
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'CACHE_PROGRESS' && progressBar && progressText) {
          const { filesCached, totalFiles, done } = event.data.payload
          const percent = totalFiles > 0 ? (filesCached / totalFiles) * 100 : 0
          
          progressBar.style.width = `${percent}%`
          progressText.textContent = `${filesCached} / ${totalFiles}`

          if (done) {
            localStorage.setItem(CACHE_COMPLETED_KEY, 'true')
            console.log('Content caching complete.')
            // Hide the progress bar after it hits 100%
            setTimeout(() => {
              progressWrapper?.setAttribute('data-open', 'false')
            }, 500)
          }
        }
      })

      // Tell the Service Worker to start caching
      reg.active.postMessage({ type: 'CACHE_ALL_CONTENT' })

    } catch (e) {
        console.error('Error during PWA install logic:', e);
        progressWrapper?.setAttribute('data-open', 'false');
    }
  }

  runPwaInstallLogic()
</script>

<script>
  // @ts-expect-error virtual:pwa-register is a virtual module
  import { registerSW } from 'virtual:pwa-register'

  const toast = document.getElementById('pwa-toast')

  const updateSW = registerSW({
    onNeedRefresh() {
      toast?.setAttribute('data-open', 'true')
    },
  })

  document.getElementById('pwa-refresh')?.addEventListener('click', () => {
    updateSW(true)
  })

  document.getElementById('pwa-close')?.addEventListener('click', () => {
    toast?.setAttribute('data-open', 'false')
  })
</script>

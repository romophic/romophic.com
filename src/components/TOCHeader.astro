---
import { ScrollArea } from '@/components/ui/scroll-area'
import { cn, getHeadingMargin } from '@/lib/utils'
import type { MarkdownHeading } from 'astro'
import { Icon } from 'astro-icon/components'

type Props = {
  headings: MarkdownHeading[]
}

const { headings } = Astro.props
---

{
  headings && headings.length > 0 && (
    <mobile-toc id="mobile-toc-container" class="block w-full xl:hidden">
      <details class="group">
        <summary class="flex w-full cursor-pointer items-center justify-between">
          <div class="mx-auto flex w-full max-w-3xl items-center px-4 py-3">
            <div class="relative mr-2 size-4">
              <svg class="h-4 w-4" viewBox="0 0 24 24">
                <circle
                  class="text-primary/20"
                  cx="12"
                  cy="12"
                  r="10"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <circle
                  id="mobile-toc-progress-circle"
                  class="text-primary"
                  cx="12"
                  cy="12"
                  r="10"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-dasharray="62.83"
                  stroke-dashoffset="62.83"
                  transform="rotate(-90 12 12)"
                />
              </svg>
            </div>
            <span
              id="mobile-toc-current-section"
              class="text-muted-foreground flex-grow truncate text-sm"
            >
              Overview
            </span>
            <span class="text-muted-foreground ml-2">
              <Icon
                name="lucide:chevron-down"
                class="h-4 w-4 transition-transform duration-200 group-open:rotate-180"
              />
            </span>
          </div>
        </summary>

        <ScrollArea
          client:load
          className="mx-auto max-w-3xl"
          data-toc-header-scroll
        >
          <div class="max-h-[30vh]">
            <ul
              class="flex list-none flex-col gap-y-2 px-4 pb-4"
              id="mobile-table-of-contents"
            >
              {headings.map((heading) => (
                <li
                  class={cn(
                    'px-4 text-sm',
                    getHeadingMargin(heading.depth),
                    'text-foreground/60',
                  )}
                >
                  <a
                    href={`#${heading.slug}`}
                    class="mobile-toc-item underline decoration-transparent underline-offset-[3px] transition-colors duration-200 hover:decoration-inherit"
                    data-heading-id={heading.slug}
                  >
                    {heading.text}
                  </a>
                </li>
              ))}
            </ul>
          </div>
        </ScrollArea>
      </details>
    </mobile-toc>
  )
}

<script>
  const INITIAL_OVERVIEW_TEXT = 'Overview'
  const HEADER_OFFSET = 102 + 36
  const PROGRESS_CIRCLE_RADIUS = 10
  const PROGRESS_CIRCLE_CIRCUMFERENCE = 2 * Math.PI * PROGRESS_CIRCLE_RADIUS

  class MobileTOC extends HTMLElement {
    private progressCircle: HTMLElement | null = null
    private currentSectionText: HTMLElement | null = null
    private detailsElement: HTMLDetailsElement | null = null
    private listElement: HTMLElement | null = null
    private scrollArea: HTMLElement | null = null
    private headings: HTMLElement[] = []
    private regions: { id: string; start: number; end: number }[] = []
    private activeIds: string[] = []

    constructor() {
      super()
      this.handleScroll = this.handleScroll.bind(this)
      this.handleResize = this.handleResize.bind(this)
      this.updateProgressCircle = this.updateProgressCircle.bind(this)
      this.updateScrollMask = this.updateScrollMask.bind(this)
    }

    connectedCallback() {
      this.init()
    }

    disconnectedCallback() {
      window.removeEventListener('scroll', this.handleScroll)
      window.removeEventListener('scroll', this.updateProgressCircle)
      window.removeEventListener('resize', this.handleResize)
    }

    init() {
      this.progressCircle = this.querySelector('#mobile-toc-progress-circle')
      this.currentSectionText = this.querySelector(
        '#mobile-toc-current-section',
      )
      this.detailsElement = this.querySelector('details')
      this.listElement = this.querySelector('#mobile-table-of-contents')
      this.scrollArea = this.querySelector('[data-radix-scroll-area-viewport]')

      if (this.progressCircle) {
        this.progressCircle.style.strokeDasharray =
          PROGRESS_CIRCLE_CIRCUMFERENCE.toString()
        this.progressCircle.style.strokeDashoffset =
          PROGRESS_CIRCLE_CIRCUMFERENCE.toString()
      }

      this.buildRegions()

      if (!this.currentSectionText) return

      if (this.headings.length === 0) {
        this.currentSectionText.textContent = INITIAL_OVERVIEW_TEXT
        window.addEventListener('scroll', this.updateProgressCircle, {
          passive: true,
        })
        this.updateProgressCircle()
        return
      }

      this.activeIds = this.getVisibleIds()
      this.updateLinks(this.activeIds)
      this.updateProgressCircle()

      this.setupInteraction()
      window.addEventListener('scroll', this.handleScroll, { passive: true })
      window.addEventListener('resize', this.handleResize, { passive: true })
    }

    buildRegions() {
      this.headings = Array.from(
        document.querySelectorAll<HTMLElement>(
          '.prose h2, .prose h3, .prose h4, .prose h5, .prose h6',
        ),
      )

      if (this.headings.length === 0) {
        this.regions = []
        return
      }

      this.regions = this.headings.map((heading, index) => {
        const nextHeading = this.headings[index + 1]
        return {
          id: heading.id,
          start: heading.offsetTop,
          end: nextHeading ? nextHeading.offsetTop : document.body.scrollHeight,
        }
      })
    }

    getVisibleIds(): string[] {
      if (this.headings.length === 0) return []

      const viewportTop = window.scrollY + HEADER_OFFSET
      const viewportBottom = window.scrollY + window.innerHeight
      const visibleIds = new Set<string>()

      const isInViewport = (top: number, bottom: number) =>
        (top >= viewportTop && top <= viewportBottom) ||
        (bottom >= viewportTop && bottom <= viewportBottom) ||
        (top <= viewportTop && bottom >= viewportBottom)

      this.headings.forEach((heading) => {
        const headingBottom = heading.offsetTop + heading.offsetHeight
        if (isInViewport(heading.offsetTop, headingBottom)) {
          visibleIds.add(heading.id)
        }
      })

      this.regions.forEach((region) => {
        if (region.start <= viewportBottom && region.end >= viewportTop) {
          const heading = document.getElementById(region.id)
          if (heading) {
            const headingBottom = heading.offsetTop + heading.offsetHeight
            if (
              region.end > headingBottom &&
              (headingBottom < viewportBottom || viewportTop < region.end)
            ) {
              visibleIds.add(region.id)
            }
          }
        }
      })

      return Array.from(visibleIds)
    }

    handleScroll() {
      const newActiveIds = this.getVisibleIds()

      if (JSON.stringify(newActiveIds) !== JSON.stringify(this.activeIds)) {
        this.activeIds = newActiveIds
        this.updateLinks(this.activeIds)
      }

      this.updateProgressCircle()
    }

    handleResize() {
      this.buildRegions()
      const newActiveIds = this.getVisibleIds()
      if (JSON.stringify(newActiveIds) !== JSON.stringify(this.activeIds)) {
        this.activeIds = newActiveIds
        this.updateLinks(this.activeIds)
      }
      this.updateProgressCircle()
    }

    updateLinks(headingIds: string[]) {
      if (!this.listElement || !this.currentSectionText) return

      this.listElement.querySelectorAll('.mobile-toc-item').forEach((item) => {
        const tocItem = item as HTMLElement
        const headingId = tocItem.dataset.headingId
        if (headingId && headingIds.includes(headingId)) {
          tocItem.classList.add('text-foreground')
        } else {
          tocItem.classList.remove('text-foreground')
        }
      })

      if (headingIds.length > 0) {
        this.scrollToActive(headingIds[0])
      }

      this.updateCurrentSectionText(headingIds)
    }

    updateCurrentSectionText(headingIds: string[]) {
      if (!this.currentSectionText) return

      let textToShow = INITIAL_OVERVIEW_TEXT

      if (headingIds.length > 0) {
        const activeTexts = this.headings
          .filter(
            (heading) => headingIds.includes(heading.id) && heading.textContent,
          )
          .map((heading) => heading.textContent!.trim())

        if (activeTexts.length > 0) {
          textToShow = activeTexts.join(', ')
        }
      }

      this.currentSectionText.textContent = textToShow
    }

    scrollToActive(activeHeadingId: string) {
      if (!this.listElement) return

      const activeItem = this.listElement.querySelector(
        `[data-heading-id="${activeHeadingId}"]`,
      )
      if (!activeItem) return

      const scrollContainer = this.scrollArea
      if (!scrollContainer) return

      const { top: containerTop, height: containerHeight } =
        scrollContainer.getBoundingClientRect()
      const { top: itemTop, height: itemHeight } =
        activeItem.getBoundingClientRect()

      const currentItemTop = itemTop - containerTop + scrollContainer.scrollTop
      const targetScroll = Math.max(
        0,
        Math.min(
          currentItemTop - (containerHeight - itemHeight) / 2,
          scrollContainer.scrollHeight - scrollContainer.clientHeight,
        ),
      )

      if (Math.abs(targetScroll - scrollContainer.scrollTop) > 5) {
        scrollContainer.scrollTop = targetScroll
      }
    }

    setupInteraction() {
      if (!this.listElement) return

      this.listElement.querySelectorAll('.mobile-toc-item').forEach((item) => {
        item.addEventListener('click', () => {
          if (this.detailsElement) this.detailsElement.open = false
        })
      })

      if (this.scrollArea) {
        this.scrollArea.addEventListener(
          'scroll',
          () => this.updateScrollMask(),
          { passive: true },
        )
      }

      if (this.detailsElement) {
        this.detailsElement.addEventListener('toggle', () => {
          if (this.detailsElement?.open) {
            setTimeout(this.updateScrollMask, 100)
          }
        })
      }
    }

    updateProgressCircle() {
      if (!this.progressCircle) return

      const scrollableDistance =
        document.documentElement.scrollHeight - window.innerHeight
      const scrollProgress =
        scrollableDistance > 0
          ? Math.min(Math.max(window.scrollY / scrollableDistance, 0), 1)
          : 0

      this.progressCircle.style.strokeDashoffset = (
        PROGRESS_CIRCLE_CIRCUMFERENCE *
        (1 - scrollProgress)
      ).toString()
    }

    updateScrollMask() {
      if (!this.scrollArea) return

      const { scrollTop, scrollHeight, clientHeight } = this.scrollArea
      const threshold = 5
      const isAtTop = scrollTop <= threshold
      const isAtBottom = scrollTop >= scrollHeight - clientHeight - threshold

      this.scrollArea.classList.toggle('mask-t-from-80%', !isAtTop)
      this.scrollArea.classList.toggle('mask-b-from-80%', !isAtBottom)
    }
  }

  customElements.define('mobile-toc', MobileTOC)
</script>

/// <reference lib="webworker" />
// src/pwa-sw.ts
// @ts-expect-error - workbox-core types not available
import { clientsClaim } from 'workbox-core'
// @ts-expect-error - workbox-routing types not available
import { registerRoute, setCatchHandler } from 'workbox-routing'
// @ts-expect-error - workbox-strategies types not available
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies'
// @ts-expect-error - workbox-cacheable-response types not available
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
// @ts-expect-error - workbox-expiration types not available
import { ExpirationPlugin } from 'workbox-expiration'

declare let self: ServiceWorkerGlobalScope

// --- Basic Setup ---
self.skipWaiting()
clientsClaim()

// --- Cache Naming ---
// We're creating a unique cache name for this version of the site.
const CACHE_VERSION = 'v1.2' // Increment this to force-update caches
const CONTENT_CACHE = `content-${CACHE_VERSION}`

// --- Precache Manifest ---
// The manifest is injected by a placeholder `self.__WB_MANIFEST`.
// This contains the list of all files generated by the build process.
const precacheManifest = self.__WB_MANIFEST || []
const precacheUrls = precacheManifest.map((entry: string | { url: string }) =>
  typeof entry === 'string' ? entry : entry.url,
)

// --- Caching Strategies for Runtime Requests ---

// Cache images with a CacheFirst strategy: serve from cache, falling back to network.
registerRoute(
  ({ request }: { request: Request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: CONTENT_CACHE,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }), // Cache opaque responses (for CORS images)
      new ExpirationPlugin({
        maxEntries: 100, // Store more images
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  }),
)

// Cache CSS and JS with a StaleWhileRevalidate strategy: serve from cache while revalidating in the background.
registerRoute(
  ({ request }: { request: Request }) =>
    request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: CONTENT_CACHE,
  }),
)

// --- Manual Precache Logic & Lifecycle ---

// On activate, clean up old caches.
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            // Delete caches that are not our current content cache
            if (cacheName !== CONTENT_CACHE) {
              console.log(`[SW] Deleting old cache: ${cacheName}`)
              return caches.delete(cacheName)
            }
          }),
        )
      })
      .then(() => self.clients.claim()),
  )
})

// Listen for the command from the client to cache everything.
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'CACHE_ALL_CONTENT') {
    console.log('[SW] Received command to cache all content.')
    event.waitUntil(
      caches.open(CONTENT_CACHE).then(async (cache) => {
        const totalFiles = precacheUrls.length
        let filesCached = 0
        const allClients = await self.clients.matchAll({
          includeUncontrolled: true,
          type: 'window',
        })

        // Helper to post progress messages to the client
        const postProgress = (payload: Record<string, unknown>) => {
          for (const client of allClients) {
            client.postMessage({ type: 'CACHE_PROGRESS', payload })
          }
        }

        // Add all files from the manifest to the cache
        for (const url of precacheUrls) {
          try {
            // Check if already in cache to avoid re-downloading
            const response = await cache.match(url)
            if (!response) {
              await cache.add(url)
            }
            filesCached++
            // Don't send too many messages, maybe batch them in a real app
            postProgress({ filesCached, totalFiles })
          } catch (e) {
            console.error(`[SW] Failed to cache ${url}`, e)
          }
        }
        postProgress({ filesCached, totalFiles, done: true })
        console.log('[SW] Content caching complete.')
      }),
    )
  }
})

// --- Navigation & Offline Fallback ---

// For navigation requests, use a Network-First strategy.
// This ensures users get the latest content when online, but can still access it offline.
const navigationHandler = async ({ request }: { request: Request }) => {
  try {
    // 1. Try to fetch from the network
    const networkResponse = await fetch(request)

    // 2. If successful, cache the response and return it
    const cache = await caches.open(CONTENT_CACHE)
    cache.put(request, networkResponse.clone())
    return networkResponse
  } catch {
    // Changed from `catch (error)` to `catch`
    // 3. If network fails, try to serve from the cache
    const cachedResponse = await caches.match(request)
    return cachedResponse
  }
}

registerRoute(
  ({ request }: { request: Request }) => request.mode === 'navigate',
  navigationHandler,
)

// Global fallback for any failed fetch requests (e.g., page not in cache and network offline)
setCatchHandler(async ({ request }: { request: Request }) => {
  // Check if it's a navigation request
  if (request.mode === 'navigate') {
    console.log('[SW] Fetch failed; returning offline fallback page.')
    return (await caches.match('/404')) || Response.error()
  }
  // For other types of requests (images, etc.), just return an error
  return Response.error()
})
